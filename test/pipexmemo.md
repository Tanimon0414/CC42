## access関数
access関数とは？
access関数は、指定したファイルやディレクトリが存在するかどうか、また、現在のプロセスがそのファイルに対して特定の操作（読み取り、書き込み、実行）を行う権限を持っているかどうかをチェックするための標準ライブラリ関数です。

この関数は、実際にファイルを開いたり操作したりする前に、アクセス権の有無を素早く確認したい場合などに便利です
#include <stdio.h>
#include <unistd.h>

int main() {
    const char *filepath = "test.txt";

    // F_OKを使ってファイルの存在をチェック
    if (access(filepath, F_OK) == 0) {
        printf("ファイル '%s' は存在します。\n", filepath);
    } else {
        // accessが-1を返した場合、perrorでエラー内容を表示できる
        perror("access");
        printf("ファイル '%s' は存在しないか、アクセスできません。\n", filepath);
    }

    return 0;
}

## execve関数
execve関数は、「execute vector」の略で、現在のプロセスを、指定した新しいプログラムで完全に置き換えるための関数です
#include <stdio.h>
#include <unistd.h>

// main関数の第3引数で環境変数を取得
int main(int argc, char *argv[], char *envp[]) {
    // 実行したいコマンドのパス
    char *path = "/bin/ls";

    // 渡したいコマンドライン引数の配列 (argv)
    // argv[0] はコマンド名、argv[1] は "-l"、argv[2] は "/tmp"
    // 配列の最後は必ず NULL にする
    char *new_argv[] = { "ls", "-l", "/tmp", NULL };

    // 渡したい環境変数の配列 (envp)
    // ここでは新しい環境変数を2つ定義
    // 配列の最後は必ず NULL にする
    char *new_envp[] = { "USER=guest", "HOME=/tmp", NULL };

    printf("これから execve を呼び出します。成功すればこのメッセージは一度しか表示されません。\n");
    printf("--- execveによる出力ここから ---\n");

    // execve の呼び出し
    // execve(path, new_argv, new_envp);
    // 現在の環境変数をそのまま引き継ぎたい場合は、mainの第3引数 envp を渡す
    execve(path, new_argv, envp);

    // !!! 注意 !!!
    // execveが成功した場合、以下のコードは絶対に実行されない
    perror("execve"); // execveが失敗した場合のみ、ここが実行されエラーが表示される
    printf("execve の呼び出しに失敗しました。\n");
    
    return 1; // 失敗したことを示す
}
forkとの組み合わせ：最も重要な使い方
execveは現在のプロセスを「乗っ取って」しまうため、元のプログラムの処理を続けたい場合には不便です。そのため、実際には**fork関数と組み合わせて使うのが定石**です。
## fork関数について
fork()は**「今実行している自分自身のプロセスを、ほぼ完全にコピーして、新しいプロセス（子プロセス）を作る」**ためのシステムコールです
## pipe関数
pipe()関数は、カーネル内に**一方向のデータ通信路（パイプ）**を作成するためのシステムコールです。
書式（プロトタイプ）
C

#include <unistd.h>

int pipe(int pipefd[2]);
引数
pipefd[2]: 要素数2のint型の配列を渡します。pipe()が成功すると、この配列に2つの新しいファイルディスクリプタが格納されます。

pipefd[0]: パイプの読み込み専用の口（出口）。
pipefd[1]: パイプの書き込み専用の口（入口）。
この 0 が読み込み、1 が書き込みという対応は固定です。絶対に覚えてください。

戻り値
成功: 0 を返します。
失敗: -1 を返し、グローバル変数errnoにエラーの原因を示す値が設定されます。
fork()との組み合わせ：最も重要な使い方
pipe()は、一つのプロセス内で作ってもあまり意味がありません。その真価は、fork()と組み合わせることで発揮されます。親プロセスと子プロセスで、パイプの入口と出口を分担して通信するのです。

親から子へデータを送る手順
pipe()作成: 親プロセスがpipe()を呼び出し、パイプを作成します。これで pipefd[0] と pipefd[1] の2つの口が手に入ります。
fork()実行: 親プロセスがfork()を呼び出し、子プロセスを作成します。fork()の性質により、ファイルディスクリプタである pipefd は子プロセスに完全にコピーされます。
不要な口を閉じる（最重要！）:
親プロセスは子にデータを書き込むだけなので、読み込み口は不要です。close(pipefd[0]); を呼び出します。
子プロセスは親からデータを読み込むだけなので、書き込み口は不要です。close(pipefd[1]); を呼び出します。
通信: 親はwrite(pipefd[1], ...)でデータを書き込み、子はread(pipefd[0], ...)でデータを受け取ります。
なぜ不要な口を閉じるのが重要なのか？
これはpipeを使う上で最も重要な作法です。主な理由はEOF（End-of-File）の検知のためです。

読み込み側は、パイプの書き込み口が「すべて」閉じられると、パイプ内のデータをすべて読み切った後にEOF（read()の戻り値が0）を検知して、読み込みが完了したことを知ります。
## dup2関数
dup2()は、「duplicate 2」の略で、既存のファイルディスクリプタを、指定した別のファイルディスクリプタに複製（コピー）するためのシステムコールです。

単純なコピーと違うのは、**「Aという行き先を、Bという行き先と全く同じにする」という、いわば「行き先のすり替え」**を行う点です。

## wait vs waitpid の違い
この2つは、親プロセスが子プロセスの終了を待つための関数です。主な違いは**「誰を待つか」と「どう待つか」**の柔軟性にあります。

一言で言うと、

wait: 誰でもいいから一人の子の終了をひたすら待つシンプル版。
waitpid: 特定の子を、待ち方を指定して待てる高機能版。
比較表
特徴	wait (シンプル)	waitpid (高機能)
待機対象	任意の子プロセス1つ	特定の子を指定可能 (pid引数)
待ち方	必ずブロックする（待たされる）	ノンブロッキング可能 (WNOHANGオプション)
柔軟性	低い	高い
主な用途	子が1つだけ、など単純なケース	複数の子を管理、ブロックしたくない場合など高度なケース


## 残りのテク

/が入っていたらそれがアクセスできるか判別しできたら返す
コマンドに/が含まれるのは、ユーザーがパスを直接指定した場合です。

絶対パス指定: /bin/ls や /usr/bin/grepのように、ルートディレクトリからの完全なパスでコマンドを指定する場合。

相対パス指定: ./a.out のようにカレントディレクトリにある実行ファイルを指定したり、../my_script/run.sh のように別のディレクトリにあるファイルを指定する場合。

このようにパスが直接指定された場合、プログラムは環境変数PATHを探しに行く必要がありません。その指定されたパスに実行可能ファイル（X_OK）があるかだけを確認すれば良いため、効率的です。

open関数のフラグとパーミッション (あなたの質問)
all->output_fd = open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644);の意味はわからないから教えて

採点: 素晴らしい質問です！ (Excellent question!)

解説: この一行はファイル操作において非常に重要です。分解して見てみましょう。

O_WRONLY: ファイルを書き込み専用で開きます。

O_CREAT: もしファイルが存在しない場合、新規に作成します。

O_TRUNC: もしファイルが既に存在する場合、その中身をすべて消して空（サイズを0）にします。

| (パイプ記号): これは「ビット単位OR演算子」で、上記の複数のオプション（フラグ）を組み合わせるために使います。つまり「書き込み専用で、なければ作り、あれば中身を空にする」という設定です。

0644: これはO_CREATでファイルが新規作成される場合のアクセス権限（パーミッション）です。

最初の0は8進数表記であることを示します。

6 (所有者): 読み取り(4) + 書き込み(2) = 6。自分は読み書きできます。

4 (グループ): 読み取り(4)のみ可能です。

4 (その他): 読み取り(4)のみ可能です。