プログラムの主な流れ
処理は大きく分けて、**「初期化」→「メインループ（入力受付→解析→実行）」→「終了」**というステップで進みます。

開始
│
├── 1. 初期化 (main関数)
│   ├── 環境変数のコピー
│   └── シグナルハンドラの設定
│
└── 2. メインループ (while (1))
    │
    ├── (Read) プロンプト表示とコマンド入力 (`readline`)
    │
    ├── (Eval) コマンド解析 (`parse_commands`)
    │   ├── トークン化 (単語、|, <, > などに分割)
    │   ├── 構文エラーチェック
    │   ├── 環境変数展開 (`$PATH`, `$?` など)
    │   └── コマンド実行用のデータ構造(t_cmd)を構築
    │
    └── (Eval) コマンド実行 (`execute_pipeline`)
        │
        ├── (単一のビルトインコマンドの場合)
        │   └── cd, export, exitなどを直接実行
        │
        └── (パイプラインや外部コマンドの場合)
            ├── fork() で子プロセスを作成
            ├── 子プロセス内:
            │   ├── パイプやリダイレクションを設定 (`dup2`)
            │   └── コマンドを実行 (`execve` またはビルトイン関数)
            └── 親プロセス内:
                └── 子プロセスの終了を待機 (`waitpid`)

(Ctrl+Dでループを抜け、終了処理へ)

## 各ステップの詳細
1. 初期化
プログラムは minishell.c の main 関数から始まります。

環境変数のコピー (copy_envp): export や unset コマンドで環境変数を変更できるように、プログラム起動時の環境変数を独自のメモリ領域にコピーして保持します。

シグナルハンドラの設定 (setup_signals):

ctrl-C (SIGINT) が押されたときに、新しいプロンプトを表示するための処理 (sigint_handler) を設定します。

ctrl-\ (SIGQUIT) は無視するように設定されます。

2. メインループ (REPL)
初期化が終わると、main 関数内の while(1) ループに入り、ユーザーが ctrl-D を押すか exit コマンドを入力するまで以下の処理を繰り返します。

Read: 入力受付
readline() 関数を使い、minishell$  というプロンプトを表示してユーザーからの入力を一行受け取ります。readlineライブラリのおかげで、カーソルキーによるコマンド履歴の利用などが可能になっています。

入力が空、またはクォートが閉じられていない場合は、適切に対応します。

有効な入力は add_history() 関数で履歴に追加されます。

Eval: 解析
受け取ったコマンドライン文字列（line）は、実行できる形に解析されます。この処理は主に minishell.c の parse_commands 関数が担います。

トークン化 (shell_split): コマンドラインを意味のある単位（トークン）に分割します。例えば、ls -l | grep "file" は ls, -l, |, grep, "file" というトークンに分けられます。クォーテーションで囲まれた部分は一つのトークンとして扱われます。

構文解析: トークンの並び順をチェックし、| | のような不正な構文がないか検証します (validate_syntax_tokens)。

データ構造の構築: トークンを元に、パイプ | で区切られた一連のコマンドを表す t_cmd 構造体の連結リストを作成します。

各 t_cmd は、一つのコマンド（引数リスト char **args を含む）を表します。

リダイレクション (<, >, >>, <<) があれば、parse_redirection_token でファイルをオープンし、入出力先のファイルディスクリプタを infile, outfile に設定します。

expand_variables や expand_variables_and_split により、引数内の環境変数（例: $HOME）や直前の終了ステータス ($?) を実際の値に置き換えます。

Eval: 実行
解析して作成された t_cmd 連結リストを、minishell.c の execute_pipeline 関数が実行します。

単一のビルトインコマンドの特別扱い: パイプがなく、コマンドが cd, export, unset, exit のいずれかである場合、fork せずに現在のシェルプロセスで直接実行します。これにより、シェルのカレントディレクトリや環境変数を正しく変更できます。

パイプラインと外部コマンドの実行:

コマンドの数だけ fork() を呼び出し、子プロセスを生成します。

親プロセスは、パイプの不要な口を閉じ、次のコマンドのためにパイプの口を準備し、最後に生成した子プロセスの終了を waitpid() で待ちます。終了ステータスは shell.last_status に保存されます。

子プロセスは、以下の処理を行います。

I/O設定 (dup2):

前のコマンドからの入力がある場合は、標準入力をパイプの読み込み口に繋ぎ変えます。

次のコマンドへ出力する場合は、標準出力をパイプの書き込み口に繋ぎ変えます。

リダイレクションが指定されていれば、標準入出力を指定のファイルに繋ぎ変えます。

コマンド実行 (execute_cmd):

コマンドがビルトイン (echo, pwd, env 等) であれば、execute_builtin.c 内の対応する関数を呼び出して exit() します。

外部コマンドであれば、find_pathで実行ファイルのパスを探し、execve() を呼び出します。execve は、成功すると子プロセスの実行イメージを新しいプログラムで上書きします。

このループが完了すると、free_cmd_listで解析時に確保したメモリを解放し、再びプロンプトを表示して次の入力を待ちます。